#' Plot visual information related to a tvcure object.
#' @description Visualization of the estimated additive terms and of the reference (cumulative) hazard function in a tvcure object.
#'
#' @usage \method{plot}{tvcure}(x, ngrid=300, ci.level=.95, pages=0, equal.ylims=TRUE, ...)
#'
#' @param x a \code{\link{tvcure.object}}.
#' @param ngrid (optional) number of points used to plot the fitted additive terms. (Default: 300).
#' @param ci.level (optional) nominal level for the plotted pointwise credible intervals. (Default: 0.95).
#' @param pages The number of pages over which to spread the output. For example, if pages=1 then all terms will be plotted on one page with the layout performed automatically. Set to 0 to have the routine leave all graphics settings as they are. (Default 0).
#' @param equal.ylims logical indicating if the same y-limits must be used when plotting the fitted additive terms. (Default: TRUE).
#' @param ... additional generic plotting arguments.
#'
#' @details Plot of the fitted additive terms, as well as of the reference hazard \eqn{f_0(t)} and cumulative hazard \eqn{F_0(t)} functions of the fitted tvcure model in \code{x}.
#'
#' @return In addition to the plots, an invisible list generated by the \code{\link{additive.tvcure}} function is returned.
#'
#' @author Philippe Lambert \email{p.lambert@uliege.be} based on the plot.gam function in mgcv for the \code{pages} argument.
#' @references Lambert, P. and Kreyenfeld, M. (2024). Exogenous time-varying covariates in double additive cure survival model
#' with application to fertility. \emph{Journal of the Royal Statistical Society, Series A}, under review.
#'
#' @examples
#' require(tvcure)
#' ## Simulated data generation
#' beta = c(beta0=.4, beta1=-.2, beta2=.15) ; gam = c(gam1=.2, gam2=.2)
#' df.raw = simulateTVcureData(n=500, seed=123, beta=beta, gam=gam,
#'                           RC.dist="exponential",mu.cens=550)$df.raw
#' ## TVcure model fitting
#' tau.0 = 2.7 ; lambda1.0 = c(40,15) ; lambda2.0 = c(25,70) ## Optional
#' model = tvcure(~z1+z2+s(x1)+s(x2), ~z3+z4+s(x3)+s(x4), df=df.raw,
#'                tau.0=tau.0, lambda1.0=lambda1.0, lambda2.0=lambda2.0)
#' plot(model,pages=1)
#'
#' @seealso \code{\link{tvcure}}, \code{\link{tvcure.object}}, \code{\link{print.tvcure}}
#'
#' @export
#'
plot.tvcure = function(x, ngrid=300, ci.level=.95, pages=0, equal.ylims=TRUE,...){
    obj = x
    ## Compute additive term + envelope
    ## --------------------------------
    fhat = additive.tvcure(obj,ngrid=ngrid,ci.level=ci.level)
    ##
    ## Plot organization (extracted from mgcv::plot.gam)
    ## -------------------------------------------------
    n.plots = 2 + fhat$J1 + fhat$J2 ## Number of plots: f0, F0 + additive terms
    if (pages > n.plots) pages = n.plots
    if (pages < 0) pages = 0
    if (pages != 0) {
        ppp = n.plots%/%pages
        if (n.plots%%pages != 0) {
            ppp = ppp + 1
            while (ppp * (pages - 1) >= n.plots) pages = pages - 1
        }
        c = r = trunc(sqrt(ppp))
        if (c < 1) r = c = 1
        if (c * r < ppp) c = c + 1
        if (c * r < ppp) r = r + 1
        oldpar = par(mfrow = c(r, c))
    }
    else {
        ppp = 1
        oldpar = par()
    }
    if ((pages == 0 && prod(par("mfcol")) < n.plots && dev.interactive()) ||
        pages > 1 && dev.interactive())
        ask = TRUE
    else ask = FALSE
    ## if (!is.null(select)) {
    ##     ask = FALSE
    ## }
    if (ask) {
        oask = devAskNewPage(TRUE)
        on.exit(devAskNewPage(oask))
    }
    ## Plot baseline f0 & F0
    ## ---------------------
    par(mar=c(4,5,1,1))
    with(fhat, curve(f0,xlim=attr(f0,"support"),xlab="time",ylab=bquote(f[0](t))))
    with(fhat, curve(F0,xlim=attr(F0,"support"),xlab="time",ylab=bquote(F[0](t))))
    ## Plot Additive terms
    ## -------------------
    ## if ((fhat$J1 == 0)&&(fhat$J2 == 0)) return(NULL)
    if (fhat$J1 > 0){
        ylims = NULL
        if (equal.ylims) ylims =  range(lapply(fhat$f1.grid, function(x) range(x$y.mat)))
        for (j in 1:fhat$J1){
            xlab = names(fhat$f1.grid)[j]
            with(fhat$f1.grid[[j]], matplot(x, y.mat,type="l",
                                            ylim=ylims,
                                            xlab=xlab,
                                            ylab=bquote('f'[.(j)]*(.(xlab))),
                                            lwd=c(2,1,1),lty=c(1,2,2),col=1, ...))
        }
    }
    if (fhat$J2 > 0){
        ylims = NULL
        if (equal.ylims) ylims =  range(lapply(fhat$f2.grid, function(x) range(x$y.mat)))
        for (j in 1:fhat$J2){
            xlab = names(fhat$f2.grid)[j]
            with(fhat$f2.grid[[j]], matplot(x, y.mat,type="l",
                                            ylim=ylims,
                                            xlab=xlab,
                                            ylab=bquote(tilde('f')[.(j)]*(.(xlab))),
                                            lwd=c(2,1,1),lty=c(1,2,2),col=1, ...))
        }
    }
    if (pages > 0) par(oldpar)
    return(invisible(fhat))
}
