#' Plot visual information related to a tvcure object.
#' @description Visualization of the estimated additive terms and of the reference (cumulative) hazard function in a tvcure object.
#'
#' @usage \method{plot}{tvcure}(x, ngrid=300, ci.level=.95, mfrow=NULL, equal.ylims=TRUE, ...)
#'
#' @param x a \code{\link{tvcure.object}}.
#' @param ngrid (optional) number of points used to plot the fitted additive terms. (Default: 300).
#' @param ci.level (optional) nominal level for the plotted pointwise credible intervals. (Default: 0.95).
#' @param mfrow (optional) window layout to plot the additive terms.
#' @param equal.ylims logical indicating if the same y-limits must be used when plotting the fitted additive terms. (Default: TRUE).
#' @param ... additional generic plotting arguments.
#'
#' @details Plot of the fitted additive terms, as well as of the reference hazard \eqn{f_0(t)} and cumulative hazard \eqn{F_0(t)} functions of the fitted tvcure model in \code{x}.
#'
#' @return In addition to the plots, an invisible list generated by the \code{\link{additive.tvcure}} function is returned.
#'
#' @author Philippe Lambert \email{p.lambert@uliege.be}
#' @references Lambert, P. and Kreyenfeld, M. (2024). Exogenous time-varying covariates in double additive cure survival model
#' with application to fertility. \emph{Journal of the Royal Statistical Society, Series A}, under review.
#'
#' @examples
#' require(tvcure)
#' ## Simulated data generation
#' beta = c(beta0=.4, beta1=-.2, beta2=.15) ; gam = c(gam1=.2, gam2=.2) 
#' df.raw = simulateTVcureData(n=500, seed=123, beta=beta, gam=gam,
#'                           RC.dist="exponential",mu.cens=550)$df.raw
#' ## TVcure model fitting
#' tau.0 = 2.5 ; lambda1.0 = c(285,15) ; lambda2.0 = c(25,1325) ## Optional
#' model = tvcure(~z1+z2+s(x1)+s(x2), ~z3+z4+s(x3)+s(x4), df=df.raw,
#'                tau.0=tau.0, lambda1.0=lambda1.0, lambda2.0=lambda2.0)
#' plot(model)
#'
#' @seealso \code{\link{tvcure}}, \code{\link{tvcure.object}}, \code{\link{print.tvcure}}
#'
#' @export
#'
plot.tvcure = function(x, ngrid=300, ci.level=.95, mfrow=NULL, equal.ylims=TRUE,...){
    obj = x
    ## Compute additive term + envelope
    fhat = additive.tvcure(obj,ngrid=ngrid,ci.level=ci.level)
    ##
    ## Make sure to restore the graphics parameters as they were before calling the function.
    oldpar <- par(no.readonly = TRUE) ; on.exit(par(oldpar))
    ##
    ## Plot baseline f0 & F0
    ## ---------------------
    dev.new(width=10,height=5) ; par(mar=c(4,5,1,1))
    par(mfrow=c(1,2))
    with(fhat, curve(f0,xlim=attr(f0,"support"),xlab="time",ylab=bquote(f[0](t))))
    with(fhat, curve(F0,xlim=attr(F0,"support"),xlab="time",ylab=bquote(F[0](t))))
    ## Plot Additive terms
    ## -------------------
    if ((fhat$J1 == 0)|(fhat$J2 == 0)) return(NULL)
    ## Plotting window division
    if (is.null(mfrow)) mfrow=c(1,1)
    maxPlts = prod(mfrow)
    ##
    if (fhat$J1 > 0){
        ylims = NULL
        if (equal.ylims) ylims =  range(lapply(fhat$f1.grid, function(x) range(x$y.mat)))
        dev.new() ; par(mar=c(4,5,1,1),mfrow=mfrow)
        for (j in 1:fhat$J1){
            if ((j%/%(maxPlts+1) == 1)) { ## New plotting window if ...
                dev.new() ; par(mar=c(4,4,1,1),mfrow=mfrow)
            }
            xlab = names(fhat$f1.grid)[j]
            with(fhat$f1.grid[[j]], matplot(x, y.mat,type="l",
                                            ylim=ylims,
                                            xlab=xlab,
                                            ylab=bquote('f'[.(j)]*(.(xlab))),
                                            lwd=c(2,1,1),lty=c(1,2,2),col=1, ...))
        }
    }
    if (fhat$J2 > 0){
        ylims = NULL
        if (equal.ylims) ylims =  range(lapply(fhat$f2.grid, function(x) range(x$y.mat)))
        dev.new() ; par(mar=c(4,5,1,1),mfrow=mfrow)
        for (j in 1:fhat$J2){
            if ((j%/%(maxPlts+1) == 1)) { ## New plotting window if ...
                dev.new() ; par(mar=c(4,4,1,1),mfrow=mfrow)
            }
            xlab = names(fhat$f2.grid)[j]
            with(fhat$f2.grid[[j]], matplot(x, y.mat,type="l",
                                            ylim=ylims,
                                            xlab=xlab,
                                            ylab=bquote(tilde('f')[.(j)]*(.(xlab))),
                                            lwd=c(2,1,1),lty=c(1,2,2),col=1, ...))
        }
    }
    return(invisible(fhat))
}
